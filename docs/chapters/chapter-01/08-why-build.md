---
sidebar_position: 8
---

# 1.8 手写框架 vs LangChain：为什么要重造轮子？

"不要重复造轮子。"

软件工程领域被引用最多的格言之一。当我们决定自己写一个 Agent 框架，而不是基于 LangChain 开发时，很多人困惑——你们是不是在浪费时间？

聊一下这个问题。

## 真的不能造轮子吗？

Peter Steinberger 是 iOS 开发圈的传奇。他创建了 PSPDFKit，一个 PDF 渲染库，苹果、迪士尼、IBM 都在用。

2018年，他做了一个让很多人不解的决定：自己写一套 UI 渲染引擎，不用苹果的原生框架。

三年后，苹果推出 SwiftUI，他的公司从容应对——因为渲染层完全在自己手里。

这个故事的核心不是"造轮子很酷"，而是：**当轮子决定你产品上限的时候，自己造轮子可能是唯一的选择**。

LangChain 就是这样一颗轮子。

## LangChain 的诱惑

先说清楚：LangChain 是个好项目。

90,000+ GitHub Stars，100+ 集成，活跃的社区。周末快速搞出一个 AI 应用原型，LangChain 几乎是首选：

```python
from langchain import OpenAI, ConversationChain

llm = OpenAI(temperature=0.9)
conversation = ConversationChain(llm=llm)

response = conversation.predict(input="你好！")
```

几行代码，一个对话机器人跑起来了。这种体验确实让人上瘾。

LangChain 的核心价值：

| 优势 | 说明 |
|------|------|
| 快速起步 | 一周内做出可演示的原型 |
| 生态丰富 | 100+ 向量库、LLM、工具集成 |
| 社区支持 | 遇到问题？Stack Overflow 有答案 |
| 持续更新 | 最新模型和最佳实践快速跟进 |

原型验证、学习探索、简单应用场景，LangChain 是不错的选择。

但把原型变成生产系统，事情就变得微妙了。

## 抽象的代价

### 黑盒效应

LangChain 的便利来自抽象。但抽象有代价——你失去对细节的控制。

一个真实场景：Agent 在调用某个工具时失败了。报错信息：

```
ToolExecutionError: Tool failed to execute
```

为什么失败？可能是提示词格式问题，可能是参数解析问题，可能是 LLM 输出问题。几层抽象之后，很难快速定位。

我们遇到过这样的案例：一个团队花了三天追踪一个 bug，最后发现是 LangChain 内部的一个 prompt 模板和他们的 prompt 冲突了。

**调试抽象层代码，往往比调试自己写的代码更花时间。**

### 性能开销

LangChain 的架构是层层包装的：

```
你的代码
  → LangChain Chain
    → LangChain Agent
      → LangChain Tool
        → LangChain LLM
          → OpenAI API
```

每一层都有中间件、日志、检查、转换。原型阶段无关紧要，但生产环境里，它们累积起来就是真金白银。

一个 Fintech 公司的真实数据：

| 指标 | LangChain 版本 | 手写版本 | 差异 |
|------|---------------|---------|------|
| 平均响应延迟 | 2.3 秒 | 1.4 秒 | 39% 降低 |
| P99 延迟 | 4.1 秒 | 2.5 秒 | 39% 降低 |
| 月度 Token 成本 | $18,500 | $11,200 | 39% 降低 |
| 调试时间（bug） | 3-5 天 | 0.5-1 天 | 70% 降低 |

**年度节省：约 $200,000**

这个数字不是理论推算，是真实的账单。

### 锁定风险

LangChain 发展很快——有时候太快了。

2023 年，LangChain 经历了多次重大 API 变更。对快速演进的开源项目来说，这很正常。但对生产系统来说，这意味着：

- 代码可能突然 break
- 需要跟进学习新 API
- 旧版本的 bug 不会有人修

核心业务逻辑建立在别人快速迭代的 API 上，你就在承担这个风险。

### 审计困境

在金融、医疗、政务等需要合规审计的领域，LangChain 的抽象会成为噩梦。

审计师问："你的系统如何确保不会泄露用户数据？"

用 LangChain，你需要解释：
1. 你的代码
2. LangChain 的 Chain 实现
3. LangChain 的 Agent 实现
4. LangChain 的 Tool 实现
5. LangChain 的 LLM wrapper 实现
6. ...

手写？你只需要解释：你的代码。

**审计员更信任你能解释清楚的代码。**

## 手写框架的价值

### 完全可控

手写框架的核心价值在于：每一行代码，你都能解释它在做什么。

```python
class Agent:
    def __init__(self, llm, tools):
        self.llm = llm
        self.tools = {t.name: t for t in tools}
    
    def run(self, input: str) -> str:
        # 步骤 1：解析意图
        intent = self._parse_intent(input)
        
        # 步骤 2：选择工具
        tool = self._select_tool(intent)
        
        # 步骤 3：执行
        result = tool.run(intent.params)
        
        # 步骤 4：格式化输出
        return self._format_output(result)
```

没有魔法，没有黑盒。出了问题，立刻知道是哪个步骤。

### 性能极致

手写框架只包含你需要的功能。不需要的中间件、检查、抽象——统统不要。

前面提到的 Fintech 公司，重写框架后：

- **40% 延迟降低**：去掉了不必要的中间层
- **39% 成本降低**：更精确的 prompt 控制，减少 token 浪费
- **70% 调试时间减少**：代码可控，问题一目了然

### 成本优化

算一笔账。

系统每天处理 100 万次 LLM 调用，每次调用平均 500 tokens，GPT-4 的价格是 $0.01/1K tokens。

**日成本**：1,000,000 × 500 / 1,000 × $0.01 = **$5,000**
**年成本**：$5,000 × 365 = **$1,825,000**

手写框架能优化 prompt，减少 20% 的 token 消耗：

**年节省**：$1,825,000 × 20% = **$365,000**

这个数字，足够雇 2-3 个高级工程师全职维护框架。

### 长期稳定

手写框架的另一个好处是稳定性。

不用担心上游库的 API 变更，不需要跟进不相关的功能更新，不用处理依赖冲突。

代码库按照你的节奏演进，而不是被外部项目的发布周期牵着走。

### 审计友好

在需要审计的场景，手写框架的优势更明显：

```
审计检查清单：
✅ 所有 LLM 调用都有日志
✅ 所有工具调用都有权限检查
✅ 所有用户数据都有脱敏处理
✅ 所有错误都有追踪和告警
```

每一项，都能直接在代码里找到对应的实现，不需要翻阅第三方库的源码。

## 决策框架

手写框架不是万能药。LangChain 依然有它的价值。

关键问题：**你在什么阶段，解决什么问题？**

```
              ┌─────────────────────────────────────┐
              │           开始新项目                │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │   这是原型验证还是生产系统？         │
              └─────────────────┬───────────────────┘
                                │
                   ┌────────────┴────────────┐
                   │                         │
                   ▼                         ▼
           ┌───────────────┐         ┌───────────────┐
           │  原型/学习    │         │  生产系统     │
           └───────┬───────┘         └───────┬───────┘
                   │                         │
                   ▼                         ▼
           ┌───────────────┐         ┌───────────────────────┐
           │  使用 LangChain │         │  系统复杂度如何？      │
           └───────────────┘         └───────────┬───────────┘
                                                 │
                                    ┌────────────┴────────────┐
                                    │                         │
                                    ▼                         ▼
                            ┌───────────────┐         ┌───────────────┐
                            │  简单场景     │         │  复杂场景     │
                            │ (单一 LLM)    │         │ (多 Agent)    │
                            └───────┬───────┘         └───────┬───────┘
                                    │                         │
                                    ▼                         ▼
                            ┌───────────────┐         ┌───────────────┐
                            │ LangChain     │         │  手写框架     │
                            │ + 定制扩展    │         │ (MiniClaw)    │
                            └───────────────┘         └───────────────┘
```

### 选 LangChain 的场景

- 快速原型验证
- 学习 AI 应用开发
- 简单的单一功能应用
- 对延迟和成本不敏感
- 没有严格的合规要求

### 选手写框架的场景

- 高并发生产系统
- 对延迟有严格要求（<1秒）
- 需要精细控制成本
- 需要通过合规审计
- 多 Agent 复杂协作场景
- 团队有维护框架的能力

### 中间路线

现实往往是折中的：

1. **LangChain 起步，逐步替换**
   - 用 LangChain 快速验证
   - 找到性能瓶颈后，逐模块替换成自己实现

2. **LangChain + 手写核心**
   - 用 LangChain 处理外围逻辑
   - 核心业务逻辑自己实现

3. **MiniClaw 的做法**
   - 学习 LangChain 的设计思想
   - 只实现自己需要的部分
   - 保持极简和可控

## MiniClaw 的选择

OpenClaw 团队在选择技术路线时，评估了 LangChain、LlamaIndex 等主流框架，最后决定自己实现。

原因很简单：

### 1. 我们需要极致性能

OpenClaw 面向企业级生产环境。客户对响应延迟有严格要求，多一秒延迟都可能影响业务。

LangChain 的抽象层带来的 30-50% 延迟开销，对我们来说无法接受。

### 2. 我们需要完全可控

Agent 系统是 OpenClaw 的核心能力。如果这部分代码依赖第三方库，出了问题无法快速定位和修复，对客户是不可接受的风险。

### 3. 我们有维护能力

团队有丰富的框架开发经验，维护一个极简的 Agent 框架不是负担，反而是一种投资。

### 4. 我们希望读者理解本质

写这本书的目的之一，是让读者真正理解 Agent 系统的工作原理。只学会调用 LangChain API，那只是学会了使用工具。

自己写出一个 Agent 框架，才算真正理解了 Agent。

### MiniClaw 的设计哲学

MiniClaw 的设计遵循三个原则：

| 原则 | 说明 |
|------|------|
| 极简 | 只保留核心功能，不追求大而全 |
| 可扩展 | 提供清晰的扩展点，方便定制 |
| 透明 | 没有魔法，每一行代码都可理解 |

具体的五层架构，下一章详细展开。

## 总结

"不要重复造轮子"的前提是：**那个轮子正好满足你的需求**。

当现成的轮子带来不可接受的性能开销、限制了你需要的控制能力、增加了维护和审计的复杂度时，自己造轮子就不是重复劳动，而是必要的投资。

LangChain 是个优秀的工具，但它不是万能的。理解它的边界，在合适的场景使用它，在必要的时候自己写——这是成熟的工程师思维。

下一章，我们开始从零实现 MiniClaw。
